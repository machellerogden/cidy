#!/usr/bin/env bash

# Library of functions for setting runtime environment based on a given
# environment key (gri-dev, gri-stage, gri-prod, gra-prod)

init-env() {
    export TARGET_DIR="${TARGET_DIR:-"$(pwd)"}"
    select-env-key
    case "$ENV_KEY" in
        gri-dev|gri-stage|gri-dark|gri-prod|gra-dev|gra-stage|gra-dark|gra-prod)
            export-env "$ENTRY_DIR/config/deploy/deploy.$ENV_KEY.env"

            # some ugly conditionals to accomodate jenkins for now...
            if [ -n "$CI" ] && [[ $ENV_KEY = gra-* ]]; then
                AWS_PROFILE="prod"
            fi

            ;;
        *)
            echo
            echo "Please specific a runtime environment."
            echo
            echo "Valid values are:"
            echo "    gri-dev"
            echo "    gri-stage"
            echo "    gri-prod"
            echo "    gri-dark"
            echo "    gra-dev"
            echo "    gra-stage"
            echo "    gra-dark"
            echo "    gra-prod"
            echo
            exit 1
            ;;
    esac
}

select-env-key() {
    if [ -n "$ENV_KEY" ]; then
       return 0
    fi
    print-prompt "Which environment do you want to target?\n"
    local options=("gri-dev" "gri-stage" "gri-dark" "gri-prod" "gra-dev" "gra-stage" "gra-dark" "gra-prod")
    local code=1
    local opt
    select opt in "${options[@]}"
    do
        case ${opt} in
            *)
                export ENV_KEY=$opt
                return 0
                ;;
        esac
    done
}

export-env() {
    local target="$1"
    echo "target: $target"
    set -a
    [ -f "$target" ] && source "$target"
    [ -p "$target" ] && source "$target"
    set +a
}

set-env-config() {
    export-env "$ENTRY_DIR/config/config.$ENV_KEY.env"
}

set-env-secrets() {
    if [ -f "$ENTRY_DIR/config/secrets.$ENV_KEY.env" ]; then
        export-env "$ENTRY_DIR/config/secrets.$ENV_KEY.env"
    else
        aws configure set default.s3.signature_version s3v4
        export-env <(aws --profile $AWS_PROFILE s3 cp "$S3_SECRETS" -)
    fi
}

set-env-local() {
    export-env "$ENTRY_DIR/config/config.local.env"           # source tracked local config
    export-env "$ENTRY_DIR/local.env"   # source ignored local config, if exists
}

set-env-test() {
    export-env "$ENTRY_DIR/config/config.test.env"
}

set-env() {
    init-env
    set-env-config
    [ -z "$TEST" ] && set-env-secrets
    [ "$LOCAL" = "true" ] && set-env-local
    [ "$TEST" = "true" ] && set-env-test
}

validate-env-vars() {
    local missing=()
    local var_name
    for var_name in "$@"
    do
        ! (: "${!var_name?}") 2>/dev/null && missing+=( "$var_name" )
    done
    if [ "${#missing[@]}" -gt 0 ]; then
        print-error "Missing required config: ${missing[*]}"
        exit 1
    fi
    return 0
}
